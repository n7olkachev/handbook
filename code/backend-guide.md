# Code guide для backend разработчиков

Серебряных пуль не бывает. Идеал не достижим. Но к нему можно и нужно стремиться.
Данное полотно текста представляет из себя набор **объективных** *рекомендаций*, которые помогают в принятии хороших
и избежании плохих решений.

## Общее

Для того, чтобы писать код, не нужно много чего уметь и знать. Дети в школе отлично с этим справляются. Они реализовывают
классические алгоритмы, работают с графикой, им показывают HTML и CSS. Если бы вместо Pascal их сразу садили за PHP, уверен,
что они без проблем могли бы создавать простые сайты.

Этот пример хорошо иллюстрирует проблему терминологии. Под программированием люди часто понимают лишь написание кода, что
является самой примитивной частью всего процесса, не требующей затратной интеллектуальной деятельности. Именно поэтому
адекватные менеджеры не оценивают эффективность подчиненных программистов количеством написанного кода.

> My point today is that, if we wish to count lines of code, we should not regard them as “lines produced” 
> but as “lines spent”: the current conventional wisdom is so foolish as to book that count on the wrong
> side of the ledger.
> 
> Edsger W. Dijkstra

Цель этого гайда: осветить проблемы поддерживаемости, переиспользуемости, корректности и показать способы решения
этих проблем.

## Красота -- побочный эффект качества

"Красота" не должна являться вашей целью при разработке. Во-первых, она субъективна. То, что вам кажется "красивым" может
являться примером плохого кода. Новички часто этим грешат: многим кажется, что максимально компактный (думая в терминах    
объема) код -- максимально красивый, из-за чего называют переменные и функции одной буквой, а в одну строку лепят как можно
больше всего. На выходе получается неподдерживаемый код, создатели которого сами в скором времени не смогут понять что он
делает. И что в этом "красивого"? Во-вторых, качественный код в любом случае будет "красивым". Это свойство является лишь
побочным эффектом. Если вам кажется, что пример качественного кода некрасив -- скорее всего вы пока просто не можете
увидеть его красоту. Поэтому не сильно зацикливайтесь на такой субъективной оценке, лучше потраться время на изучение
действительно полезных техник.

## The Zen of Python

Классика. Ознакомиться с этим списком будет полезно каждому. А лучше хорошенько поразмыслить.

https://www.python.org/dev/peps/pep-0020/

* Beautiful is better than ugly.
* Explicit is better than implicit.
* Simple is better than complex.
* Complex is better than complicated.
* Flat is better than nested.
* Sparse is better than dense.
* Readability counts.
* Special cases aren't special enough to break the rules.
* Although practicality beats purity.
* Errors should never pass silently.
* Unless explicitly silenced.
* In the face of ambiguity, refuse the temptation to guess.
* There should be one-- and preferably only one --obvious way to do it.
* Although that way may not be obvious at first unless you're Dutch.
* Now is better than never.
* Although never is often better than *right* now.
* If the implementation is hard to explain, it's a bad idea.
* If the implementation is easy to explain, it may be a good idea.
* Namespaces are one honking great idea -- let's do more of those!

## Разделение ответственности (Separation of concerns)

Одна из самих простых для базового понимания, но в тоже время глубоких концепций в программировании.
Помните времена одного большого index.php? Сразу становится страшно, да? А вы точно понимаете **почему**?

Если вашим ответом является "ну, это большой файл, большие файлы -- плохо" -- вы неправы! Да, с малыми по объему
файлами работать просто, но это не означает того, что все большие файлы -- "плохие". Какой-нибудь стандартный класс
String из Java довольно внушителен по объему (больше 3000 строк), однако понять его содержимое вряд ли составит
большого труда (за исключением, возможно, пары методов, что, впрочем, никак не связано с объемом файла).

Проблема великого и ужасного index.php заключается в том, что этот единственный файл *ответственнен*
за всю логику приложения. Работа с БД? index.php. Аутентификация? index.php. Футер личного кабинета? index.php!
Работать с, а уж тем более понимать работу такого файла действительно трудоемкая задача.

Вроде как с самой проблемой разобрались. Когда и где применять? Всегда и везде! Нужно время, чтобы научиться замечать вещи,
которые лежат не на своем месте, однако пренебрегая этим правилом вы делаете слишком больно проекту (плохо проекту = плохо
людям, которым придется с ним работать, в т.ч. и вам самим). Если не получается увидеть или не знаете, где коду будет
спаться спокойней -- попробуйте обратиться к стандартным паттернам или попросту спросите. Стоит заметить, что если вы
спрашиваете совета, важно **понять** ответ. Если вы услышали, что это нужно обернуть в отдельный класс,
или положить в репозиторий, а вы раньше и слова такого не слышали -- почитайте, узнайте. Глупо перекладывая из
одного места в другое вы ничему не научитесь и скорее всего все равно совершите ошибку.

## Информационный эксперт (Information Expert)

Простой и полезный. Если выбираете место, куда бы ваш код поместить, лучшими кандидатами будут места, обладающие бОльшим
количеством необходимой информации для исполнения вашего кода. Хорошим примером могут послужить геттеры. Чем везде по 
проекту разбрасывать "#{user.first_name} #{user.last_name}", лучше создать метод User#full_name.
Тем более, если логика получения полного имени изменится, вам скажут спасибо.

## Принцип открытости/закрытости (The Open Closed Principle)

Прекрасный принцип, который сильно окупается в будущем. Для понимания его важности следует подумать о том, откуда в нашем
коде появляются баги. Если достаточно долгое время программа работает корректно, можно предположить, что она и дальше будет
так работать. Проблемы появляются, когда код *изменяется*. Вы поправили что-то здесь, код поломолася где-то там. Знакомая
многим ситуация, не так ли? Данный принцип помогает нам попросту уходить от *изменений* кода. Объясняя этот принцип: когда
вам нужно что-то добавить, вы пишите *новый* код, не трогая старый. Нет *изменений*, нет проблем изменений, все просто.

Платой за применение этого принципа является время. Это один из тех принципов, где вы *проигрываете* в начале и только
лишь в будущем начинаете получать выгоду. Или не начинаете, если вы не угадали и этот участок кода никто и никогда больше
не трогал, никакого нового функционала там не появлялось, а потом его просто выкинули. Вот тогда вы просто проиграли.
К сожалению, многие вещи приходится именно видеть и угадывать, что приходит только с опытом. Однако, бывают ситуации, где
вы заведомо знаете о будущем. Например, вы делаете интеграцию с каким-то сервисом и вам прямым текстом говорят: "Сейчас
занимаемся только ими, но через месяц появятся еще два сервиса". В таком случае угадывать ничего не нужно, нужно делать.
При успешной реализации добавление новых интеграций будет происходить безболезненно и, кстати, скорее всего куда быстрее,
чем первая интеграция. Все в плюсе, всем хорошо, вы молодец.

Кстати, с этим принципом зачастую сильно помогает полиморфизм, поэтому, если вы не знаете что это -- читайте.
